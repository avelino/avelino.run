{
  "title" : "Automating newsletter delivery with Hugo, Resend, and GitHub Actions: building an active community around your static site",
  "date" : "2025-11-02T00:00:00+00:00",
  "tags" : [ ],
  "url" : "https://avelino.run/automating-newsletter-hugo-resend-github-actions-building-active-community",
  "content" : "Building an audience around a static site is fundamentally different from social media. While platforms like Twitter or LinkedIn provide built-in notification systems, static sites are silent by default. Your readers discover your content only if they remember to check back—which they rarely do.\n\nThis is the core problem: how do you keep your community engaged when your publishing platform has no native notification system?\n\nThe answer isn't to abandon static sites for dynamic platforms. It's to add the missing notification layer through automation. In this article, I'll show you how to build a Substack-like newsletter system for Hugo sites using Resend.com and GitHub Actions—complete with duplicate prevention, automatic post detection, and community engagement mechanisms.\n\nThe static site engagement problem\n\nStatic site generators like Hugo excel at performance, simplicity, and hosting economics. They generate pure HTML, CSS, and JavaScript that can be served from CDNs for pennies. But this architectural strength creates an engagement weakness: there's no server-side logic to notify readers when new content is published.\n\nTraditional solutions have significant drawbacks:\n\n- RSS feeds: Require readers to actively use feed readers—most don't\n- Social media announcements: Fragment your audience across platforms and create dependency on external networks (see Interactions: IRL vs. Social Media - What Really Matters? for why direct channels matter)\n- Email newsletters: Manual effort creates friction; posts often go unannounced or get announced inconsistently\n\nThe gap between publishing and notifying leads to a classic problem: you write great content, but your audience never knows it exists. Engagement metrics stagnate, and the community you're trying to build remains dormant.\n\nThe automation solution: Hugo + Resend + GitHub Actions\n\nThe solution is to automate the entire notification flow:\n\n1. Detect new posts automatically when you commit to your repository\n2. Extract content metadata (title, description, URL) from markdown frontmatter\n3. Send broadcast emails via Resend's broadcast API to all subscribers\n4. Prevent duplicate sends by tracking what's already been delivered\n5. Update state automatically in version control for auditability\n\nThis creates a closed loop: write → commit → publish → notify. No manual steps, no forgotten announcements, no duplicate sends.\n\nWhy this architecture works\n\nGitHub Actions as the orchestrator: Actions trigger on git events, making them perfect for content published detection. The workflow runs in a sandboxed environment with access to your repository state, git history, and secrets. (For more on GitHub Actions workflows, see How to reuse workflow in GitHub Action pipeline.)\n\nResend for email delivery: Resend's broadcast API is designed for newsletters. Unlike transactional email APIs, broadcasts are optimized for one-to-many sends with built-in unsubscribe handling and delivery tracking.\n\nState management in git: Tracking sent posts in .newsletter_state.json keeps the system auditable and reproducible. Every change is versioned, making it easy to understand what was sent when.\n\nHugo frontmatter as the data source: Markdown frontmatter already contains title, description, and URL—everything needed to generate newsletter content without additional configuration.\n\nImplementation: building the system\n\nThe implementation consists of three components:\n\n1. GitHub Actions workflow\n\nThe workflow triggers on pushes to content/blog/ and executes the newsletter script:\n\n``yaml\nname: Newsletter on new post\n\non:\n  push:\n    branches: [main]\n    paths:\n      - content/blog/\n\njobs:\n  send-broadcast:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 2  Needed for git diff\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n      - name: Install deps\n        run: npm ci || npm i\n      - name: Send newsletter broadcast\n        run: node .github/scripts/send_newsletter.mjs\n        env:\n          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}\n          RESEND_AUDIENCE_ID: ${{ secrets.RESEND_AUDIENCE_ID }}\n          NEWSLETTER_FROM: ${{ secrets.NEWSLETTER_FROM }}\n          SITE_BASE_URL: ${{ secrets.SITE_BASE_URL }}\n      - name: Commit newsletter state\n        run: |\n          git config user.name GitHub Actions\n          git config user.email actions@github.com\n          git add .newsletter_state.json\n          git commit -m update newsletter state [skip ci] || echo no changes\n          git push\n`\n\nKey design decisions:\n\n- fetch-depth: 2: Required to compare HEAD~1 and HEAD for detecting new files\n- Path-based triggering: Only runs when blog content changes, reducing unnecessary executions\n- Automatic state commit: Updates the tracking file and commits it back, creating an audit trail\n\n2. Newsletter script\n\nThe script handles detection, extraction, and sending:\n\n`javascript\nimport fs from 'fs';\nimport path from 'path';\nimport { Resend } from 'resend';\nimport matter from 'gray-matter';\nimport { execSync } from 'child_process';\n\n// Detect new files via git diff\nconst diff = execSync('git diff --name-status HEAD~1 HEAD').toString();\nconst added = diff\n  .split('\\n')\n  .map(l => l.trim().split('\\t'))\n  .filter(p => p[0] === 'A' && p[1] && p[1].startsWith('content/blog/'))\n  .map(p => p[1])\n  .filter(f => /\\.(md|mdx)$/.test(f));\n\n// Read state to prevent duplicates\nconst statePath = path.join(process.cwd(), '.newsletter_state.json');\nlet state = { lastSent: [] };\nif (fs.existsSync(statePath)) {\n  state = JSON.parse(fs.readFileSync(statePath, 'utf8'));\n}\n\n// Process each new post\nfor (const postPath of added) {\n  const fileId = postPath.replace(/^content\\/blog\\//, '');\n\n  if (state.lastSent.includes(fileId)) {\n    continue; // Skip already sent posts\n  }\n\n  // Extract frontmatter and content\n  const raw = fs.readFileSync(postPath, 'utf8');\n  const { data, content } = matter(raw);\n\n  // Generate email HTML\n  const html = generateEmailHTML(data, content);\n\n  // Send broadcast\n  const resend = new Resend(process.env.RESEND_API_KEY);\n  await resend.broadcasts.create({\n    audienceId: process.env.RESEND_AUDIENCE_ID,\n    from: process.env.NEWSLETTER_FROM,\n    subject: Novo post: ${data.title},\n    html,\n  });\n\n  // Update state\n  state.lastSent.push(fileId);\n  fs.writeFileSync(statePath, JSON.stringify(state, null, 2));\n}\n`\n\nThe script's logic:\n\n- Git-based detection: Uses git diff to find files added in the latest commit—more reliable than file timestamps\n- Frontmatter parsing: Uses gray-matter to extract Hugo frontmatter, including custom URL fields\n- Duplicate prevention: Checks .newsletter_state.json before sending, ensuring posts are only sent once\n- Broadcast API: Uses Resend's broadcast endpoint, which is optimized for newsletter delivery\n\n3. State management\n\nThe .newsletter_state.json file tracks all sent posts:\n\n`json\n{\n  lastSent: [\n    blog/2025-11-automating-newsletter-hugo-resend-github-actions.md,\n    blog/2025-10-open-source-governance-reference-leading-engineering-teams.md\n  ]\n}\n`\n\nThis file is:\n\n- Versioned in git: Full history of what was sent when\n- Human-readable: Easy to inspect and debug\n- Immutable: Posts are never removed from the list, preventing re-sends even if the file is reset\n\nCommunity engagement mechanisms\n\nThe automation doesn't just solve the technical problem—it creates engagement patterns. This aligns with broader principles of community building in open source, where consistent, automated communication channels reduce friction and enable scalable engagement:\n\n1. Consistent delivery timing\n\nReaders learn when to expect your content. Automation ensures every post is announced, building trust through reliability.\n\n2. Zero-friction publishing\n\nNo manual steps means you're more likely to publish consistently. The system removes the I should announce this on email mental overhead.\n\n3. Direct relationship with readers\n\nEmail newsletters create a direct channel that you own. Unlike social media platforms, there's no algorithm deciding who sees your content. This direct communication is the most efficient way to scale your outreach, as text-based communication allows for asynchronous, thoughtful engagement.\n\n4. Analytics and feedback\n\nResend provides delivery analytics: open rates, click rates, and subscriber growth. This data helps you understand what resonates with your audience.\n\n5. Unsubscribe handling\n\nResend automatically handles unsubscribe requests and maintains compliance with email regulations (GDPR, CAN-SPAM). The system respects user preferences without manual intervention.\n\nTechnical considerations and edge cases\n\nHandling multiple posts in one commit\n\nThe script processes all new posts in a commit sequentially. If you publish multiple posts at once, each gets its own broadcast email—readers see all new content, not just the latest.\n\nURL generation from Hugo permalinks\n\nHugo's permalink configuration can generate URLs that don't match the file path. The script handles this by:\n\n1. Checking frontmatter url field first (Hugo's explicit URL)\n2. Falling back to slug if present\n3. Defaulting to filename-based slug if neither exists\n\nThis ensures newsletter links always point to the correct published URL.\n\nInitial state population\n\nWhen setting up the system, populate .newsletter_state.json with existing posts to prevent re-sending:\n\n`bash\nfind content/blog -name *.md | sed 's|^content/||' | jq -R -s 'split(\\n) | map(select(length > 0))' > .newsletter_state.json\n`\n\nError handling\n\nThe script exits on error, causing the GitHub Action to fail. This surfaces issues immediately:\n\n- Missing environment variables\n- Resend API errors\n- File system errors\n\nAction logs show exactly what went wrong, making debugging straightforward.\n\nComparison with alternatives\n\n| Approach | Pros | Cons |\n|----------|------|------|\n| Manual email | Full control, personal touch | Time-consuming, easy to forget |\n| RSS to email services | No code required | Limited customization, service dependency |\n| WordPress plugins | Easy setup | Requires WordPress, plugin maintenance |\n| This solution | Automated, version-controlled, scalable | Requires GitHub, initial setup |\n\nThe automated approach scales: whether you publish once a month or daily, the system handles it without additional effort.\n\nConclusion: automation as community infrastructure\n\nBuilding an active community around static content requires making your publishing system push rather than pull. Automation transforms static sites from silent archives into active communication channels.\n\nThe Hugo + Resend + GitHub Actions combination provides:\n\n- Zero-maintenance operation: Write and commit—the system handles the rest\n- Duplicate prevention: State management ensures posts are never sent twice\n- Audit trail: Git history shows exactly what was sent when\n- Scalability: Handles one post or hundreds without additional configuration\n- Direct ownership: You own the subscriber list, email templates, and delivery mechanism\n\nMost importantly, this system turns consistency into a default behavior rather than a conscious effort. When publishing becomes as simple as git commit && git push`, you're more likely to maintain the publishing cadence that keeps communities engaged.\n\nThe technical details matter, but the real value is in creating infrastructure that supports long-term community building. Automation removes friction, and removing friction enables consistency. Consistency is what builds engaged communities.\n\n---\n\nImplementation resources\n\n- Resend Broadcast API Documentation\n- GitHub Actions Documentation\n- Hugo Content Management\n- gray-matter Package",
  "type" : "blog",
  "file-path" : "content/blog/2025-11-automating-newsletter-hugo-resend-github-actions-building-active-community.md"
}