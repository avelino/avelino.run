{
  "title" : "ChronDB: Transforming a Clojure Database into a Polyglot Library with GraalVM Native Image and FFI",
  "date" : "2026-01-25T00:00:00+00:00",
  "tags" : [ ],
  "url" : "https://avelino.run/chrondb-polyglot-ffi-clojure-graalvm-native-image",
  "content" : "ChronDB was born as a server. A time-traveling key/value database with Git as its storage engine, exposing PostgreSQL wire protocol, Redis protocol, and REST/HTTP. You'd download the server, run it, connect with your favorite client. Classic architecture.\n\nThen I started building spuff — ephemeral dev environments in the cloud. Spin up when needed, auto-destroy when forgotten. Written in Rust. For state management, I reached for SQLite. Simple, embedded, no server to manage. Just a file.\n\nBut something kept nagging at me: why SQLite?\n\nThe state I was storing was simple. Key-value pairs. Configuration. Session data. Nothing that truly needed SQL. And I already had a database designed exactly for this use case — ChronDB. Time-travel for debugging. Git-native storage for versioning. Perfect fit.\n\nExcept for one problem: ChronDB was a server written in Clojure. My CLI was in Rust. I didn't want to force users to run a JVM process just to store some ephemeral state.\n\nThe question became: how do I embed ChronDB directly into a Rust binary?\n\nI remembered solving a similar problem before. When building the prestd plugin system, we needed to expose Go code to other languages. The solution was compiling to a shared library and using FFI. Could the same approach work for Clojure?\n\nThe answer was GraalVM Native Image — and what started as a hack to avoid SQLite became an architecture that now lets ChronDB run embedded in Rust, Python, or any language that can load a .so file.\n\nThe Architecture at a Glance\n\nThe system is organized in five layers, from top (user-facing) to bottom (core):\n\n1. Language Bindings (Rust, Python) — Safe wrappers, JSON parsing, resource management\n2. C API (libchrondb.so/dylib) — @CEntryPoint functions via GraalVM native-image --shared\n3. Java Bridge (ChronDBLib.java) — Lazy-loads Clojure, converts C ↔ Java types\n4. Clojure Bridge (chrondb.lib.core) — Handle registry, orchestrates Storage + Index\n5. ChronDB Core — GitStorage + LuceneIndex\n\nEach layer has a specific responsibility, creating clean separation of concerns while maintaining the ability to cross language boundaries efficiently.\n\nLayer 1: The Clojure Core and Handle Registry\n\nAt the foundation, we have pure Clojure code managing database connections. The key insight here is the handle registry pattern - a thread-safe mapping between integer handles and database instances:\n\n``clojure\n(defonce ^:private ^AtomicInteger handle-counter (AtomicInteger. 0))\n(defonce ^:private handle-registry (atom {}))\n\n(defn lib-open [data-path index-path]\n  (try\n    (let [storage (git/create-git-storage data-path)\n          idx (lucene/create-lucene-index index-path)]\n      (when (and storage idx)\n        (lucene/ensure-index-populated idx storage nil {:async? false})\n        (let [handle (.getAndIncrement ^AtomicInteger handle-counter)]\n          (swap! handle-registry assoc handle {:storage storage :index idx})\n          handle)))\n    (catch Throwable _e -1)))\n`\n\nWhy integers instead of pointers? Because integers cross the FFI boundary cleanly. An int is the same in C, Rust, Python, and Java. No pointer gymnastics, no memory layout concerns. The actual objects stay safely inside the JVM/native image, referenced only by their integer handle.\n\nThis pattern is documented extensively in Foreign Function Interface in Modern Programming and follows the classic opaque handle design that Win32 APIs popularized decades ago.\n\nLayer 2: The Java Bridge with @CEntryPoint\n\nGraalVM Native Image requires a Java layer to define C-callable entry points. Each function is annotated with @CEntryPoint, which tells the native-image compiler to export this function with C ABI:\n\n`java\n@CEntryPoint(name = chrondb_open)\npublic static int open(IsolateThread thread,\n                       CCharPointer dataPath,\n                       CCharPointer indexPath) {\n    try {\n        ensureInitialized();\n        String dp = toJavaString(dataPath);\n        String ip = toJavaString(indexPath);\n        Object result = libOpen.invoke(dp, ip);\n        if (result instanceof Number) {\n            return ((Number) result).intValue();\n        }\n        lastError = open returned non-numeric result;\n        return -1;\n    } catch (Exception e) {\n        lastError = e.getClass().getName() + :  + e.getMessage();\n        return -1;\n    }\n}\n`\n\nNotice several critical design decisions:\n\n1. Lazy Clojure initialization: ensureInitialized() loads Clojure runtime only on first call\n2. Type conversion: CCharPointer <-> String using GraalVM's CTypeConversion\n3. Error handling: Exceptions never cross FFI boundaries - we store errors in lastError and return sentinel values (-1)\n4. IsolateThread parameter: GraalVM requires an isolate thread context for all entry points\n\nThe ensureInitialized() method demonstrates lazy loading of Clojure namespaces:\n\n`java\nprivate static synchronized void ensureInitialized() {\n    if (!initialized) {\n        IFn require = Clojure.var(clojure.core, require);\n        require.invoke(Clojure.read(chrondb.lib.core));\n\n        libOpen = Clojure.var(chrondb.lib.core, lib-open);\n        libClose = Clojure.var(chrondb.lib.core, lib-close);\n        libPut = Clojure.var(chrondb.lib.core, lib-put);\n        // ... more function references\n\n        initialized = true;\n    }\n}\n`\n\nThis is the IFn pattern - storing references to Clojure functions as IFn objects that can be invoked from Java. It's the standard way to call Clojure from Java, and it works perfectly inside native images.\n\nLayer 3: Building the Shared Library\n\nThe build process has three distinct phases, orchestrated by shared_library.clj:\n\nPhase 1: Uberjar Creation\n\n`clojure\n(build/-main --uberjar)\n`\n\nCreates a single JAR containing all dependencies - the Clojure runtime, JGit, Lucene, and ChronDB itself.\n\nPhase 2: Java Compilation with SVM Classpath\n\n`clojure\n(defn- compile-java! [graalvm-home]\n  (let [svm-jars (find-svm-jars graalvm-home)\n        uberjar-path (.getAbsolutePath (io/file build/jar-file))\n        classpath (string/join : (concat svm-jars [uberjar-path]))]\n    (shell/sh javac\n              -cp classpath\n              -d target/shared-classes\n              -source 11 -target 11\n              java/chrondb/lib/ChronDBLib.java)))\n`\n\nThe key here is adding GraalVM's SVM (Substrate VM) JARs to the classpath. These provide the @CEntryPoint annotations and CTypeConversion utilities.\n\nPhase 3: Native Image Arguments\n\n`clojure\n(let [shared-args (concat [--shared\n                           -H:Name=libchrondb\n                           (str -H:Path= target-path)]\n                          processed)]\n  (spit shared-args-file (string/join \\n shared-args)))\n`\n\nThe --shared flag is the magic switch that tells native-image to produce a shared library instead of an executable. The output includes:\n\n- libchrondb.so (Linux) / libchrondb.dylib (macOS) - the shared library\n- libchrondb.h - C header with function declarations\n- graal_isolate.h - GraalVM isolate management types\n\nLayer 4: Python Bindings with ctypes\n\nPython's ctypes module provides direct access to C shared libraries. Our FFI layer configures function signatures:\n\n`python\ndef load_library():\n    lib = ctypes.CDLL(lib_path)\n\n    GraalVM Isolate Management\n    lib.graal_create_isolate.argtypes = [c_void_p, POINTER(c_void_p), POINTER(c_void_p)]\n    lib.graal_create_isolate.restype = c_int\n\n    ChronDB Functions\n    lib.chrondb_open.argtypes = [c_void_p, c_char_p, c_char_p]\n    lib.chrondb_open.restype = c_int\n\n    lib.chrondb_put.argtypes = [c_void_p, c_int, c_char_p, c_char_p, c_char_p]\n    lib.chrondb_put.restype = c_char_p\n\n    return lib\n`\n\nThe safe wrapper class manages the GraalVM isolate lifecycle:\n\n`python\nclass ChronDB:\n    def __init__(self, data_path: str, index_path: str):\n        self._lib = load_library()\n        self._isolate = c_void_p()\n        self._thread = c_void_p()\n\n        ret = self._lib.graal_create_isolate(\n            None, byref(self._isolate), byref(self._thread)\n        )\n        if ret != 0:\n            raise ChronDBError(Failed to create GraalVM isolate)\n\n        self._handle = self._lib.chrondb_open(\n            self._thread,\n            data_path.encode('utf-8'),\n            index_path.encode('utf-8')\n        )\n\n    def put(self, id: str, doc: dict, branch: str = None) -> dict:\n        json_str = json.dumps(doc).encode('utf-8')\n        result = self._lib.chrondb_put(\n            self._thread,\n            self._handle,\n            id.encode('utf-8'),\n            json_str,\n            branch.encode('utf-8') if branch else None\n        )\n        return json.loads(result.decode('utf-8'))\n`\n\nKey Python FFI considerations:\n\n1. String encoding: Always encode to UTF-8 bytes before passing to C\n2. Memory management: GraalVM manages the returned strings; Python's ctypes handles the conversion\n3. Context managers: Implement __enter__/__exit__ for safe cleanup\n4. Library discovery: Search multiple paths (env vars, ~/.chrondb/lib/, system paths)\n\nLayer 5: Rust Bindings with bindgen\n\nRust's approach is more compile-time focused. The build.rs script uses bindgen to generate Rust FFI declarations from C headers:\n\n`rust\nlet bindings = bindgen::Builder::default()\n    .header(header_path.to_str().unwrap())\n    .clang_arg(format!(-I{}, lib_dir.display()))\n    .allowlist_function(chrondb_.)\n    .allowlist_function(graal_create_isolate)\n    .allowlist_function(graal_tear_down_isolate)\n    .allowlist_type(graal_isolate_t)\n    .allowlist_type(graal_isolatethread_t)\n    .generate()\n    .expect(Unable to generate bindings);\n`\n\nThe generated bindings are included at compile time:\n\n`rust\n// ffi.rs\ninclude!(concat!(env!(OUT_DIR), /bindings.rs));\n`\n\nThe safe Rust wrapper emphasizes ownership and RAII:\n\n`rust\npub struct ChronDB {\n    isolate: mut ffi::graal_isolate_t,\n    thread: mut ffi::graal_isolatethread_t,\n    handle: i32,\n}\n\nunsafe impl Send for ChronDB {}\n\nimpl Drop for ChronDB {\n    fn drop(&mut self) {\n        if self.handle >= 0 {\n            unsafe { ffi::chrondb_close(self.thread, self.handle); }\n            self.handle = -1;\n        }\n        if !self.thread.is_null() {\n            unsafe { ffi::graal_tear_down_isolate(self.thread); }\n            self.thread = ptr::null_mut();\n            self.isolate = ptr::null_mut();\n        }\n    }\n}\n`\n\nThe Drop implementation ensures cleanup happens automatically. No try/finally needed - Rust's ownership system guarantees drop runs when the ChronDB instance goes out of scope.\n\nType-safe operation methods use CString and serde_json:\n\n`rust\npub fn put(&self, id: &str, doc: &serde_json::Value, branch: Option<&str>) -> Result<serde_json::Value> {\n    let c_id = CString::new(id)?;\n    let json_str = serde_json::to_string(doc)?;\n    let c_json = CString::new(json_str)?;\n    let c_branch = Self::optional_cstring(branch)?;\n\n    let result = unsafe {\n        ffi::chrondb_put(\n            self.thread,\n            self.handle,\n            c_id.as_ptr() as mut c_char,\n            c_json.as_ptr() as *mut c_char,\n            Self::ptr_or_null(&c_branch),\n        )\n    };\n\n    self.parse_string_result(result)\n}\n`\n\nThe Data Flow\n\nLet's trace a put operation from Python through all layers:\n\n`\nPython: db.put(user:1, {name: Alice})\n  |\n  v\nctypes: lib.chrondb_put(thread, handle, buser:1, b'{name:Alice}', None)\n  |\n  v\nlibchrondb.so: chrondb_put(IsolateThread, int, CCharPointer, CCharPointer, CCharPointer)\n  |\n  v\nChronDBLib.java: Converts C strings to Java, calls libPut.invoke(...)\n  |\n  v\nchrondb.lib.core/lib-put: Parses JSON, calls storage/save-document\n  |\n  v\nGitStorage: Creates virtual commit with document\n  |\n  v\nLuceneIndex: Indexes document for search\n  |\n  v\nReturns JSON string back through all layers\n`\n\nEach layer handles its concerns:\n\n- Python: Encoding, type conversion, JSON serialization\n- C ABI: Memory layout, calling convention\n- Java: Exception handling, Clojure interop\n- Clojure: Business logic, persistence\n\nWhy This Architecture?\n\n1. Single source of truth: The Clojure implementation is canonical. Bindings are thin wrappers.\n\n2. No serialization overhead: Data crosses the boundary as C strings (JSON). No complex serialization protocols needed.\n\n3. Consistent behavior: Python and Rust users get identical semantics because they call the same underlying code.\n\n4. Maintainability: Changes to ChronDB core automatically propagate to all bindings after rebuilding.\n\n5. No runtime dependencies: The shared library is self-contained. No JVM required at runtime.\n\nRecommended Reading\n\nFor those wanting to dive deeper into FFI and language interoperability:\n\n- The Rust Programming Language (Klabnik & Nichols) - Chapter on FFI covers unsafe Rust, CString, and calling C from Rust. Essential for understanding how bindgen-generated code works and how Rust safely interfaces with C libraries. Source\n\n- Clojure Programming (Emerick, Carper & Grand) - Chapter on Java interop explains the IFn interface and how to call Clojure from Java - the exact pattern we use in the Java bridge layer. Source\n\nConclusion\n\nThe ChronDB polyglot architecture demonstrates that language boundaries are porous when you design for them. By leveraging GraalVM's native-image with --shared`, we transform JVM code into native shared libraries that any language can consume.\n\nThe key principles:\n\n1. Opaque handles instead of raw pointers for cross-language object references\n2. JSON as the universal data interchange format\n3. Error codes instead of exceptions at the C boundary\n4. Language-idiomatic wrappers that feel native to each ecosystem\n\nThis approach scales: adding a new language binding (Go, Ruby, Node.js via N-API) requires only implementing the FFI wrapper layer. The core remains unchanged.\n\nThe code is open source at github.com/moclojer/chrondb. PRs for new language bindings are welcome.",
  "type" : "blog",
  "file-path" : "content/blog/2026-01-25-chrondb-polyglot-ffi-clojure-graalvm-native-image.md"
}